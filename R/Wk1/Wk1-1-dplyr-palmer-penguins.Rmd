---
title: "Week 1-2 dplyr"
output: 
  moodlequiz::moodlequiz:
    replicates: 1
moodlequiz:
  category: "Week 1-2 dplyr"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# remotes::install_github("numbats/moodlequiz")
library(moodlequiz)
```

<h3>Data manipulations with Penguins!</h3>

The purpose of this section is to get some hands-on experience with data manipulation an R package **`dplyr`**. You will learn about what **pipes** are in R and some key **data manipulation verbs**!

Recall from the previous page that an R package is a set of related functions and data that can be loaded into R to help you get a specific job done. 

**Meet the penguins!**

![The Palmer Archipelago penguins. Artwork by @allison_horst.](lter_penguins.png)

> We will be working with the`palmerpenguins` data, which contains size measurements for three penguin species observed on three islands in the Palmer Archipelago, Antarctica.

The `penguins` dataset is from the `palmerpenguins` the R package so we will also need to install and load that into R. 


## Setting up

<h3>Setting up</h3>

Let's go ahead and install these two packages for the browser

> Note if you refresh the browser or check any answers as you are doing the challenges, you will need to install and load `dplyr` and `palmerpengins` again. 

```{r}
webr::install(c("dplyr","palmerpenguins"))

library(dplyr) 
library(palmerpenguins) 
```

## Take a look at the data {type=essay}

<h3>Take a look at the data</h3>

```{r}
penguins
```

**Question:** What do you notice that's different with how `mtcars` and `penguins` are presented in R? 

Write a few sentences on what functions you used to determine the main difference between the two datasets.

## But first, have you met the pipe?

Before diving into data wrangling, I want to introduce to you a very *special* operator, the pipe! `|>`. The pipe looks like a funnel on its side right? The pipe takes the code on the left side of the `|>` and passes it on to the code on the right side.  

Let's talk through an example. I want to know how many unique `islands` there are in the `penguins` dataset. Typically, I would use: 

- the `unique()` function which gives me the distinct values in a variable
- the `length()` function which counts the number of elements in a vector

The code would look like this: 

```{r}
# Recall `$` allows you to select a variable from a data frame
length(unique(penguins$island)) 
```

This is not very nice looking code, you have to read from inside out which is not very intuitive. There is where pipes come in. Here you can read from top to bottom, left to right. You can see the order of steps! 

```{r}
penguins |>  # Take the dataset
  unique() |>  # Tell me the distinct values
  length() # Tell me how long the vector is
```

> Importantly, the pipe pairs well with `dplyr` functions as it allows to do multiple data wrangling steps in one go.

## Working with `dplyr`

<h3>Working with `dplyr`</h3>

Your first challenge is to explore and try out some of dplyr functions for manipulating data tables.

> Review the examples in the dplyr guide here: <https://dplyr.tidyverse.org/articles/dplyr.html>

Then adapt the code from the guide to answer the following.

<h4>Extracting rows</h4>

<!-- TODO: Talk about conditions and operators, &, | and , and <, >, <=, => -->

*Try:* Use the pipe and function `filter()` to extract all penguins from `Dream` island

```{r}
penguins |> 
  filter(island == "Dream")
```

**Question:** How many penguins were sampled in Dream Island? `r cloze(124, c(8, 124, 3250))`

**Try:** Use the function `filter()`to extract all penguins that have body masses greater than 4000g 

```{r}
penguins |> 
  filter(body_mass_g > 4000)
```

**Question:** How many penguins were heavier than 4kg? `r cloze(172, c(101, 127, 172))`

**Try:** Use the `arrange()` function to sort the data by `island`

```{r}
penguins |> 
  arrange(island)
```

**Question:** What would the code look like if you wanted to sort the data by were heavier than 4kg? `r cloze(172, c(101, 127, 172))`

<h4>Keep or dropping columns</h4>

<!-- TODO: Talk about select is a great way to move your columns around
Talk about :, starts_with, ends_with, contains-->

**Try**: Use the `select()` function to choose columns i.e. variables

Include `species`, `island`, `year`, `flipper_length_mm`

```{r}
penguins |> 
  select(species, island, year, flipper_length_mm)
```

<h4>Create and modify columns</h4>

### Use the `mutate` function to create a variable this is the logarithim base 10 of `body_mass_g` (`log10()`, might come in handy!)

```{r}
penguins |> 
  mutate(log_10_mass = log10(body_mass_g))
```

<h4>Compute group summaries</h4>

When working with data, we often want know certain summaries about groups in our data. For example, we may need to report on the average tree canopy cover for each study sites or median house prices of different states. These are classic examples of the **split-apply-combine** paradigm. We want to split our data by group, apply a type of calculation on each of these subgroups and then bring these seperate parts together again. 

![Schematic showing splitting og data by group, applying some sort of operation, then combining the results together](split-apply-combine.png){width=70%}

In `dplyr`, the `group_by()` and `summarise()` functions are powerful tools for us to obtain group-level insights. 

Let's say I want to know how `body_mass_g` of penguins varied by `sex`, `year`, `island`. We can achieve this with 3 lines of code! We've set `mean(body_mass_g, na.rm = TRUE)` as some penguins didn't have body mass data. 

```{r}
penguins |> 
  group_by(sex, year) |>  # tell dplyr what groups I am interested in
  summarise(mean_body_mass = mean(body_mass_g, na.rm = TRUE)) # Calculate the average body mass and store that info in `mean_body_mass`
```

<h4>Using pipes with dplyr verbs</h4>

> Notice how I used the pipe twice in the code above? This is the power of the pipe + `dplyr` combo as it allows you   to chain multiple steps together to get a data wrangling job done!

Consider this example, let's say we want data for:

- female Gentoo penguins 
- that are larger than body masses greater or equal to 3500g
- mass-corrected flipper and bill length (dividing flipper and bill length by mass)
- the final dataset should only contain the mass-corrected flipper and bill length and year


But with the pipe, you can take the output of one step and pipe it in as input to the next step. E.g. the code above becomes

```{r}
penguins |> 
  filter(sex == "female", 
         species == "Gentoo",
         body_mass_g > 3500) |> 
  mutate(mass_corrected_flipper_length_mm = flipper_length_mm / body_mass_g,
         mass_corrected_bill_length_mm = bill_length_mm / body_mass_g) |> 
  select(starts_with("mass_corrected"), year)
```

Without the pipe, you would need to save the output for each step which clogs up a lot of intermediary objects in your environment and the code is a bit harder to read. 

```{r}
target_sample <- filter(penguins, 
                        sex == "female",
                        species == "Gentoo",
                        body_mass_g > 3500)


a2 <- select(a1, height, mass)
a3 <- summarise(a2,
  height = mean(height, na.rm = TRUE),
  mass = mean(mass, na.rm = TRUE)
)
a3
```



what is the average height of Clawdite females (in cm)?

```{r}

```

**Question:** Use your code from above with the pipe to create a new dataset that

- extracts all observations with human characters over 1.8m tall
- includes columns name, homeworld, mass, height
- converts mass to g and height in m

```{r}

```

What is the height of the character at the top of this new dataset?

```{r}

```

# Other miscellaneous tips for effective analysis

## Variable names

Complicated variable names are hard to work with. Especially those with spaces or special characters, like (=,+& etc.

If you do have a dataset with complicated naes, you can use tick marks to make working with it easier. E.g., imagine I have a variable "strange variable (yrs)", you could use this in code like this

```{r}
data %>%
  select(site, `strange varible (yrs)`)

```

Personally, I clean variable names to make them more R friendly.

E.g. using the rename function

```{r}
data %>%
  rename(better_variavle = `strange varible (yrs)`)

```

OR, you can use the `clean_names` function from the package `janitor` to do a general tidyup of all names

```{r}
data <- data %>% janitor::clean_names()
```

## Check distributions

It's always a good idea to check the distributions of key variables, to identity potential errors.

### Categorical variables

For categorical variables, you can look a table of values

```{r}

data$homeworld %>% table()

```

or plot it

```{r}
data %>% 
  ggplot(aes(homeworld)) + geom_bar()
```

### Numeric values

For numerical values, you can look at the range

```{r}
range(data$height, na.rm = TRUE)

range(data$birth_year, na.rm = TRUE)
```

and/or plot a histogram to look at the distribution
 
```{r}
data %>% 
  ggplot(aes(x=height) ) + 
  geom_histogram()

```

### Summaries of whole dataset

The package `skimr` has a great function `skim` for quickly summarising the structure of an entire datatset

```{r}
skimr::skim(data)
```

another one is from the package `report`

```{r}
report::report(data)
```
